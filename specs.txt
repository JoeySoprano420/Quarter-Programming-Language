# Quarter Programming Language 

> â€œReadable like English. Powerful like Assembly. Beautiful like poetry.â€ â€œBuilt to read like vision, execute like code, and endure like art.â€

---

## ğŸŒŸ Overview
**Quarter** is a high-readability, semantically rich, ultra-fluent programming language built on:
- âœ… Itemized Transformative Objectives (ITO)
- âœ… Functional Directives
- âœ… Sequential Iterative Imperatives
- âœ… Lateral Procedural Design
- âœ… Longitudinal Full Stack Scoping

It features derivative logic, dodecagram (DG) numeric base, inline NASM, and capsule compilation.

---

## ğŸ”¤ Core Syntax Structure
```quarter
star
  ...code...
end
```

---

## ğŸ§¾ Statements & Keywords
| Keyword     | Purpose                                   | Example                            |
|-------------|-------------------------------------------|------------------------------------|
| `val`       | Declare immutable variable                | `val x as int: 5`                  |
| `var`       | Declare mutable variable                  | `var score as float: 0.0`          |
| `say`       | Output a value                            | `say "hello"`                      |
| `loop`      | Create a for-loop                         | `loop from 1 to 5:`                |
| `when`      | Conditional branch                        | `when x > 0:`                      |
| `else`      | Alternative branch                        | `else:`                            |
| `derive`    | Transform one variable from another       | `derive y from x by 2`             |
| `dg`        | Declare DG (dodecagram) base-12 value     | `val z as dg: 9A1`                 |
| `match`     | Match against multiple values             | `match status:`                    |
| `case`      | Define branch for match                   | `case 0:`                          |
| `define`    | Function declaration                      | `define foo():`                   |
| `procedure` | Procedure declaration                     | `procedure do_this():`            |
| `return`    | Return from function                      | `return value`                    |
| `yield`     | Yield value in generator                  | `yield item`                      |
| `thread`    | Start new parallel thread                 | `thread handle()`                 |
| `pipe`      | Pipe output                               | `val out as pipe: "log.txt"`      |
| `fn`        | Anonymous function                        | `val adder as fn a b -> a + b`    |
| `nest`      | Scoped block                              | `nest debug:`                     |
| `stop`      | Immediate halt                            | `stop`                            |
| `asm`       | Inline NASM                               | `asm { mov rax, 1 }`              |

---

## ğŸ§  Expressions
### ğŸ”¢ Arithmetic & Logic
```quarter
val result as int: 10 + 5 * 2
```

### ğŸ” Comparison
```quarter
when x > 100:
  say "Big!"
```

### ğŸ’¬ String Interpolation
```quarter
val name as string: "Joey"
say "Hi, {name}"
```

---

## ğŸ§© Derivatives
```quarter
val base as int: 10
derive total from base by 5  # total = base + 5
```

---

## ğŸ§® Dodecagrams (DGs)
### ğŸ“Œ DG Notation
```quarter
val d as dg: 9A1
say from_dg(d)        # â†’ decimal
say to_dg(1234)       # â†’ base-12
```

### â• DG Math
```quarter
say dg_add(100, 200)  # â†’ base-12 sum
say dg_mul(12, 12)    # â†’ base-12 product
```

> DG digits: 0â€“9, X (=10), Y (=11)

---

## ğŸ” Control Flow
### ğŸ”‚ Loops
```quarter
loop from 1 to 5:
  say "Quarter Loop"
```

### ğŸ§¾ Match-Case
```quarter
match level:
  case 1:
    say "One"
  case 2:
    say "Two"
```

---

## ğŸ§· Functions & Procedures
### ğŸ§° Function Declaration
```quarter
define square(n as int):
  return n * n
```

### ğŸ” Generator Example
```quarter
define count():
  loop from 1 to 3:
    yield "tick"
```

---

## ğŸ§µ Threads & I/O
```quarter
thread run_task()
pipe write: "log.txt"
```

---

## ğŸ§¬ Inline Assembly
```quarter
asm {
  mov rax, 7
  inc rax
}
```

---

## ğŸ“¦ Capsule Format
### ğŸ“¦ `.qtrcapsule` Contains:
- Header: `QTRC`
- Version: `2`
- Sections:
  - Compressed NASM
  - Compressed Source
  - DG metadata

Used for secure, bundled execution and inspection.

---

## ğŸ§  QuarterOps Runtime Bindings
| Function       | Description                        |
|----------------|------------------------------------|
| `to_dg(n)`     | Integer â†’ Dodecagram string        |
| `from_dg(d)`   | Dodecagram string â†’ Integer        |
| `dg_add(a,b)`  | DG-style addition                  |
| `dg_mul(a,b)`  | DG-style multiplication            |

---

## âœ… Example Program
```quarter
star
val velocity as int: 88
derive momentum from velocity by 44
say momentum

val hex as dg: 9A1
say from_dg(hex)
say to_dg(1234)
say dg_add(100, 100)
say dg_mul(12, 12)

loop from 1 to 3:
  say "Quarter Running..."
end
```

---

## ğŸ”§ Coming Soon
- `capsule import/export`
- `net` and `subnet` expression pipelines
- `inline learning observers`
- `full NASM + LLVM AOT pipeline`

---

---

For more examples, join the development at: https://github.com/JoeySoprano420/Quarter-Programming-Language

> â€œBuilt to read like vision, execute like code, and endure like art.â€

# Quarter Programming Language (v3.0)

> â€œReadable like English. Powerful like Assembly. Beautiful like poetry. Now faster than C++.â€

---

## ğŸŒŸ Overview
**Quarter** is a high-readability, semantically rich, ultra-fluent programming language built on:
- âœ… Itemized Transformative Objectives (ITO)
- âœ… Functional Directives
- âœ… Sequential Iterative Imperatives
- âœ… Lateral Procedural Design
- âœ… Longitudinal Full Stack Scoping

It features derivative logic, dodecagram (DG) numeric base, inline NASM, capsule compilation, and capsule-aware AOT execution.

---

## âš¡ Quarter vs C++: Domination Blueprint
| Metric | C++ Strength | Quarter v3.0 Goal |
|--------|--------------|-------------------|
| ğŸ§  Compile-time | Fast with `clang`, `gcc` | Faster with capsule caching |
| ğŸš€ Runtime Speed | Near-optimal with hand-tuned code | Equal or better via NASM + LLVM fusion |
| ğŸ§© Memory Efficiency | Manual control | Capsule-aware memory pools |
| ğŸ§µ Concurrency | Threads, async, atomics | Native `thread`, `pipe`, `subnet` |
| ğŸ› ï¸ Tooling | Mature ecosystem | Capsule IDE + visual debugger |
| ğŸ§¬ Extensibility | Templates, macros | Inline learning observers, DG logic |

---

## ğŸ›  Compiler Architecture

### ğŸ¯ Capsule-Aware AOT Compiler
- **Frontend**: `.quarter` â†’ AST
- **IR Layer**: Custom IR â†’ LLVM IR
- **Backend**: LLVM â†’ NASM â†’ `.qtrcapsule`
- **Capsule Format**: Compressed NASM + source + DG metadata

### ğŸ§ª LLVM + NASM Hybrid
- LLVM for high-level optimization
- Direct NASM for low-level control
- Loader toggles JIT/AOT intelligently

---

## ğŸ§  QuarterOps Runtime Engine
- Written in Rust or Zig
- Features:
  - SIMD-accelerated DG arithmetic
  - Capsule memory arenas
  - Lock-free thread orchestration

### Capsule Execution
- Loads `.qtrcapsule`
- Supports:
  - Hot-swapping capsules
  - Capsule chaining via `pipe`, `subnet`
  - Inline learning observers

---

## ğŸ§® DG Arithmetic Acceleration
- AVX2/AVX-512 optimized `dg_add`, `dg_mul`
- Intrinsics for `to_dg`, `from_dg`
- Loop unrolling and constant folding for DGs

---

## ğŸ§µ Concurrency & Subnet Pipelining
- `thread` compiles to OS threads or fibers
- `pipe` â†’ memory-mapped async streams
- `subnet` defines dataflow graphs

---

## ğŸ§¬ Learning Observers
- Capsules embed real-time metrics
- Runtime dynamically tunes:
  - Thread pools
  - Memory layout
  - Unroll factors

### Capsule Profiler
- Visual heatmaps
- Export optimized variants

---

## ğŸ› ï¸ Developer Experience
### Quarter IDE
- Capsule debugger
- DG calculator
- NASM visualizer

### Capsule Playground
- Web-based REPL
- Upload capsules for testing and benchmarking

---

## ğŸ”¤ Core Syntax Structure
```quarter
star
  ...code...
end
```

## ğŸ§¾ Statements & Keywords
| Keyword     | Purpose                                   | Example                            |
|-------------|-------------------------------------------|------------------------------------|
| val       | Declare immutable variable                | val x as int: 5                  |
| var       | Declare mutable variable                  | var score as float: 0.0          |
| say       | Output a value                            | say "hello"                      |
| loop      | Create a for-loop                         | loop from 1 to 5:                |
| when      | Conditional branch                        | when x > 0:                      |
| else      | Alternative branch                        | else:                            |
| derive    | Transform one variable from another       | derive y from x by 2             |
| dg        | Declare DG (dodecagram) base-12 value     | val z as dg: 9A1                 |
| match     | Match against multiple values             | match status:                    |
| case      | Define branch for match                   | case 0:                          |
| define    | Function declaration                      | define foo():                   |
| procedure | Procedure declaration                     | procedure do_this():            |
| return    | Return from function                      | return value                    |
| yield     | Yield value in generator                  | yield item                      |
| thread    | Start new parallel thread                 | thread handle()                 |
| pipe      | Pipe output                               | val out as pipe: "log.txt"      |
| subnet    | Declare reactive pipeline                 | subnet pipeline:                |
| fn        | Anonymous function                        | val adder as fn a b -> a + b    |
| nest      | Scoped block                              | nest debug:                     |
| stop      | Immediate halt                            | stop                            |
| asm       | Inline NASM                               | asm { mov rax, 1 }              |

---

## âœ… Example Program
```quarter
star
val velocity as int: 88
derive momentum from velocity by 44
say momentum

val hex as dg: 9A1
say from_dg(hex)
say to_dg(1234)
say dg_add(100, 100)
say dg_mul(12, 12)

thread compute()
pipe output: "res.log"

loop from 1 to 3:
  say "Quarter Running..."
end
```

---

> â€œBuilt to read like vision, execute like code, and obliterate C++.â€
