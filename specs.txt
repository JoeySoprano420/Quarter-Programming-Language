# ğŸš€ Quarter Programming Language (v3.0)

> *Readable like English. Powerful like Assembly. Beautiful like poetry. Now faster than C++.*

Quarter is a next-generation, high-readability programming language built for **speed**, **clarity**, and **future-proof power**. With capsule-aware AOT compilation, inline NASM, DG arithmetic, and native threading pipelines, itâ€™s engineered to outperform C++ in real-world scenariosâ€”without sacrificing elegance.

---

## ğŸŒŸ Overview
**Quarter** is a high-readability, semantically rich, ultra-fluent programming language built on:
- âœ… Itemized Transformative Objectives (ITO)
- âœ… Functional Directives
- âœ… Sequential Iterative Imperatives
- âœ… Lateral Procedural Design
- âœ… Longitudinal Full Stack Scoping

It features derivative logic, dodecagram (DG) numeric base, inline NASM, capsule compilation, and capsule-aware AOT execution.

---

## âœ¨ Highlights
- ğŸ”¤ English-like readable syntax
- ğŸ§  Derivative-based logic (`derive`)
- ğŸ§® Built-in dodecagram base-12 math (`dg`)
- ğŸ’¥ Inline NASM injection
- âš¡ Capsule format bundling NASM + source
- ğŸ§µ Native threading and reactive `subnet` pipelines
- ğŸ“ˆ Inline learning observers and self-tuning runtime
- ğŸ” Toggle JIT/AOT execution

---

## âš¡ Quarter vs C++: Domination Blueprint
| Metric | C++ Strength | Quarter v3.0 Goal |
|--------|--------------|-------------------|
| ğŸ§  Compile-time | Fast with `clang`, `gcc` | Faster with capsule caching |
| ğŸš€ Runtime Speed | Near-optimal with hand-tuned code | Equal or better via NASM + LLVM fusion |
| ğŸ§© Memory Efficiency | Manual control | Capsule-aware memory pools |
| ğŸ§µ Concurrency | Threads, async, atomics | Native `thread`, `pipe`, `subnet` |
| ğŸ› ï¸ Tooling | Mature ecosystem | Capsule IDE + visual debugger |
| ğŸ§¬ Extensibility | Templates, macros | Inline learning observers, DG logic |

---

## ğŸ›  Compiler Architecture

### ğŸ¯ Capsule-Aware AOT Compiler
- **Frontend**: `.quarter` â†’ AST
- **IR Layer**: Custom IR â†’ LLVM IR
- **Backend**: LLVM â†’ NASM â†’ `.qtrcapsule`
- **Capsule Format**: Compressed NASM + source + DG metadata

### ğŸ§ª LLVM + NASM Hybrid
- LLVM for high-level optimization
- Direct NASM for low-level control
- Loader toggles JIT/AOT intelligently

---

## ğŸ§  QuarterOps Runtime Engine
- Written in Rust or Zig
- Features:
  - SIMD-accelerated DG arithmetic
  - Capsule memory arenas
  - Lock-free thread orchestration

### Capsule Execution
- Loads `.qtrcapsule`
- Supports:
  - Hot-swapping capsules
  - Capsule chaining via `pipe`, `subnet`
  - Inline learning observers

---

## ğŸ§® DG Arithmetic Acceleration
- AVX2/AVX-512 optimized `dg_add`, `dg_mul`
- Intrinsics for `to_dg`, `from_dg`
- Loop unrolling and constant folding for DGs

---

## ğŸ§µ Concurrency & Subnet Pipelining
- `thread` compiles to OS threads or fibers
- `pipe` â†’ memory-mapped async streams
- `subnet` defines dataflow graphs

---

## ğŸ§¬ Learning Observers
- Capsules embed real-time metrics
- Runtime dynamically tunes:
  - Thread pools
  - Memory layout
  - Unroll factors

### Capsule Profiler
- Visual heatmaps
- Export optimized variants

---

## ğŸ› ï¸ Developer Experience
### Quarter IDE
- Capsule debugger
- DG calculator
- NASM visualizer

### Capsule Playground
- Web-based REPL
- Upload capsules for testing and benchmarking

---

## ğŸ”¤ Core Syntax Structure
```quarter
star
  ...code...
end
```

---

## ğŸ§¾ Statements & Keywords
| Keyword     | Purpose                                   | Example                            |
|-------------|-------------------------------------------|------------------------------------|
| val       | Declare immutable variable                | val x as int: 5                  |
| var       | Declare mutable variable                  | var score as float: 0.0          |
| say       | Output a value                            | say "hello"                      |
| loop      | Create a for-loop                         | loop from 1 to 5:                |
| when      | Conditional branch                        | when x > 0:                      |
| else      | Alternative branch                        | else:                            |
| derive    | Transform one variable from another       | derive y from x by 2             |
| dg        | Declare DG (dodecagram) base-12 value     | val z as dg: 9A1                 |
| match     | Match against multiple values             | match status:                    |
| case      | Define branch for match                   | case 0:                          |
| define    | Function declaration                      | define foo():                   |
| procedure | Procedure declaration                     | procedure do_this():            |
| return    | Return from function                      | return value                    |
| yield     | Yield value in generator                  | yield item                      |
| thread    | Start new parallel thread                 | thread handle()                 |
| pipe      | Pipe output                               | val out as pipe: "log.txt"      |
| subnet    | Declare reactive pipeline                 | subnet pipeline:                |
| fn        | Anonymous function                        | val adder as fn a b -> a + b    |
| nest      | Scoped block                              | nest debug:                     |
| stop      | Immediate halt                            | stop                            |
| asm       | Inline NASM                               | asm { mov rax, 1 }              |

---

## âœ… Example Program
```quarter
star
val velocity as int: 88
derive momentum from velocity by 44
say momentum

val hex as dg: 9A1
say from_dg(hex)
say to_dg(1234)
say dg_add(100, 100)
say dg_mul(12, 12)

thread compute()
pipe output: "res.log"

loop from 1 to 3:
  say "Quarter Running..."
end
```

---

## ğŸ”§ Coming Soon
- `capsule import/export`
- `net` and `subnet` expression pipelines
- `inline learning observers`
- `full NASM + LLVM AOT pipeline`

---

> â€œBuilt to read like vision, execute like code, and obliterate C++.â€
