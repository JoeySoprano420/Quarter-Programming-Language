// Organized QuarterLang Compiler - C++14
// Project Layout:
// quarterc/
// ├── CMakeLists.txt
// ├── include/
// │   ├── Token.hpp
// │   ├── Lexer.hpp
// │   ├── AST.hpp
// │   ├── Parser.hpp
// │   ├── IR.hpp
// │   ├── Codegen.hpp
// │   ├── VM.hpp
// │   ├── LSP.hpp
// │   ├── Sandbox.hpp
// │   └── Memory.hpp
// ├── src/
// │   ├── main.cpp
// │   ├── Token.cpp
// │   ├── Lexer.cpp
// │   ├── AST.cpp
// │   ├── Parser.cpp
// │   ├── IR.cpp
// │   ├── Codegen.cpp
// │   ├── NasmCodegen.cpp
// │   ├── VM.cpp
// │   ├── LSP.cpp
// │   ├── Sandbox.cpp
// │   └── Memory.cpp
// └── tests/
//     ├── lexer_tests.cpp
//     ├── parser_tests.cpp
//     └── vm_tests.cpp

//------------------------------------------------------------------------------
// include/Token.hpp
//------------------------------------------------------------------------------
#pragma once
#include <string>
enum class TokenType { KEYWORD, IDENTIFIER, NUMBER, STRING, SYMBOL, DG, END_OF_FILE };
struct Token {
    TokenType type;
    std::string value;
    int line;
};

//------------------------------------------------------------------------------
// include/Lexer.hpp
//------------------------------------------------------------------------------
#pragma once
#include "Token.hpp"
#include <vector>
#include <string>

class Lexer {
public:
    explicit Lexer(const std::string& src);
    std::vector<Token> tokenize();

private:
    std::string source;
    size_t pos;
    int line;
    static const std::unordered_set<std::string> keywords;
    char peek() const;
    char advance();
    void skipWhitespace();
    void skipComment();
    Token readWord();
    Token readNumber();
    Token readString();
    Token readSymbol();
};

//------------------------------------------------------------------------------
// include/AST.hpp
//------------------------------------------------------------------------------
#pragma once
#include <vector>
#include <string>

struct ASTNode { virtual ~ASTNode() = default; };
struct ProgramNode : ASTNode { std::vector<ASTNode*> statements; };
struct ValNode : ASTNode { std::string name,type,value; };
struct SayNode : ASTNode { std::string message; };
struct LoopNode : ASTNode { std::string varName,from,to; std::vector<ASTNode*> body; };
struct ProcedureNode : ASTNode { std::string name; std::vector<std::pair<std::string,std::string>> params; std::vector<ASTNode*> body; std::string returnType; };
// ... other AST nodes

//------------------------------------------------------------------------------
// include/Parser.hpp
//------------------------------------------------------------------------------
#pragma once
#include "Token.hpp"
#include "AST.hpp"
#include <vector>

class Parser {
public:
    explicit Parser(const std::vector<Token>& tokens);
    ProgramNode* parse();

private:
    const std::vector<Token>& tokens;
    size_t current;
    Token peek() const;
    Token advance();
    bool match(const std::string&);
    void consume(const std::string&, const std::string&);
    bool isAtEnd() const;
    ASTNode* parseStatement();
    // parseVal, parseSay, parseLoop, parseProcedure, etc.
};

//------------------------------------------------------------------------------
// include/IR.hpp
//------------------------------------------------------------------------------
#pragma once
#include <vector>
#include <string>
struct IRInstr { std::string op; std::vector<std::string> args; };
std::vector<IRInstr> optimizeIR(const std::vector<IRInstr>&);

//------------------------------------------------------------------------------
// include/Codegen.hpp
//------------------------------------------------------------------------------
#pragma once
#include "IR.hpp"
#include <vector>
#include <string>
class Codegen {
public:
    void generate(const std::vector<IRInstr>&);
};

//------------------------------------------------------------------------------
// include/NasmCodegen.hpp
//------------------------------------------------------------------------------
#pragma once
#include "IR.hpp"
#include <string>
class NasmCodegen {
public:
    std::string emit(const std::vector<IRInstr>&);
};

//------------------------------------------------------------------------------
// include/VM.hpp
//------------------------------------------------------------------------------
#pragma once
#include "IR.hpp"
#include <map>
#include <stack>
#include <string>
class VM {
public:
    void execute(const std::vector<IRInstr>&);
    void debugShell(const std::vector<IRInstr>&);

private:
    struct Thread { size_t ip; std::vector<std::string> stack; std::map<std::string,std::string> locals; };
    std::vector<Thread> threads;
    std::map<std::string,bool> locks;
    std::map<std::string,std::vector<std::string>> pipes;
    std::map<std::string,int> labels;
    void executeInstr(Thread&, const IRInstr&);
    void computeBinary(Thread&, const std::string&);
    void spawnThread(const std::string&);
    void acquireLock(const std::string&);
    void releaseLock(const std::string&);
    void sendPipe(const std::string&, const std::string&);
};

//------------------------------------------------------------------------------
// include/LSP.hpp
//------------------------------------------------------------------------------
#pragma once
class LanguageServer {
public:
    void start();
};

//------------------------------------------------------------------------------
// include/Sandbox.hpp
//------------------------------------------------------------------------------
#pragma once
#include <string>
class CapsuleSandbox {
public:
    void run(const std::string&);
};

//------------------------------------------------------------------------------
// include/Memory.hpp
//------------------------------------------------------------------------------
#pragma once
#include <cstddef>
class MemoryManager {
public:
    void* alloc(size_t);
    void  free(void*);
};

//------------------------------------------------------------------------------
// src/main.cpp
//------------------------------------------------------------------------------
#include "Lexer.hpp"
#include "Parser.hpp"
#include "IR.hpp"
#include "Codegen.hpp"
#include "NasmCodegen.hpp"
#include "VM.hpp"
#include "LanguageServer.hpp"
#include "Sandbox.hpp"
#include "Memory.hpp"
#include <iostream>
#include <fstream>

int main(int argc, char** argv) {
    if (argc < 2) { std::cerr<<"Usage: quarterc <build|run|debug> [file]"; return 1; }
    std::string mode = argv[1];
    if (mode=="build") {
        std::ifstream in(argv[2]); std::string src((std::istreambuf_iterator<char>(in)),{});
        Lexer lx(src);
        auto toks = lx.tokenize();
        Parser ps(toks);
        auto ast = ps.parse();
        auto ir  = optimizeIR(/* genIR(ast) */{});
        Codegen cg; cg.generate(ir);
        NasmCodegen ng; auto asmText=ng.emit(ir);
        std::ofstream("out.asm")<<asmText;
    } else if (mode=="run"||mode=="debug") {
        // load IR from file or regenerate
        VM vm;
        std::vector<IRInstr> ir;
        vm.execute(ir);
        if (mode=="debug") vm.debugShell(ir);
    }
    return 0;
}

//------------------------------------------------------------------------------
// CMakeLists.txt
//------------------------------------------------------------------------------
#cmake_minimum_required(VERSION 3.10)
#project(quarterc CXX)
#set(CMAKE_CXX_STANDARD 14)
#include_directories(include)
#file(GLOB SOURCES "src/*.cpp")
#add_executable(quarterc ${SOURCES})
#target_link_libraries(quarterc pthread)
